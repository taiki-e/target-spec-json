// SPDX-License-Identifier: Apache-2.0 OR MIT
// This file is @generated by target_spec.sh.
// It is not intended for manual editing.

#![allow(non_camel_case_types)]

use serde_derive::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum Arch {
    aarch64,
    amdgpu,
    arm,
    arm64ec,
    avr,
    bpf,
    csky,
    hexagon,
    loongarch32,
    loongarch64,
    m68k,
    mips,
    mips32r6,
    mips64,
    mips64r6,
    msp430,
    nvptx64,
    powerpc,
    powerpc64,
    riscv32,
    riscv64,
    s390x,
    sparc,
    sparc64,
    spirv,
    wasm32,
    wasm64,
    x86,
    x86_64,
    xtensa,
}
impl Arch {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::aarch64 => "aarch64",
            Self::amdgpu => "amdgpu",
            Self::arm => "arm",
            Self::arm64ec => "arm64ec",
            Self::avr => "avr",
            Self::bpf => "bpf",
            Self::csky => "csky",
            Self::hexagon => "hexagon",
            Self::loongarch32 => "loongarch32",
            Self::loongarch64 => "loongarch64",
            Self::m68k => "m68k",
            Self::mips => "mips",
            Self::mips32r6 => "mips32r6",
            Self::mips64 => "mips64",
            Self::mips64r6 => "mips64r6",
            Self::msp430 => "msp430",
            Self::nvptx64 => "nvptx64",
            Self::powerpc => "powerpc",
            Self::powerpc64 => "powerpc64",
            Self::riscv32 => "riscv32",
            Self::riscv64 => "riscv64",
            Self::s390x => "s390x",
            Self::sparc => "sparc",
            Self::sparc64 => "sparc64",
            Self::spirv => "spirv",
            Self::wasm32 => "wasm32",
            Self::wasm64 => "wasm64",
            Self::x86 => "x86",
            Self::x86_64 => "x86_64",
            Self::xtensa => "xtensa",
        }
    }
}
impl core::fmt::Display for Arch {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum Os {
    aix,
    amdhsa,
    android,
    cuda,
    cygwin,
    dragonfly,
    emscripten,
    espidf,
    freebsd,
    fuchsia,
    haiku,
    hermit,
    horizon,
    hurd,
    illumos,
    ios,
    l4re,
    linux,
    lynxos178,
    macos,
    managarm,
    motor,
    netbsd,
    none,
    nto,
    nuttx,
    openbsd,
    psp,
    psx,
    redox,
    rtems,
    solaris,
    solid_asp3,
    teeos,
    trusty,
    tvos,
    uefi,
    unknown,
    vexos,
    visionos,
    vita,
    vxworks,
    wasi,
    watchos,
    windows,
    xous,
    zephyr,
    zkvm,
}
impl Os {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::aix => "aix",
            Self::amdhsa => "amdhsa",
            Self::android => "android",
            Self::cuda => "cuda",
            Self::cygwin => "cygwin",
            Self::dragonfly => "dragonfly",
            Self::emscripten => "emscripten",
            Self::espidf => "espidf",
            Self::freebsd => "freebsd",
            Self::fuchsia => "fuchsia",
            Self::haiku => "haiku",
            Self::hermit => "hermit",
            Self::horizon => "horizon",
            Self::hurd => "hurd",
            Self::illumos => "illumos",
            Self::ios => "ios",
            Self::l4re => "l4re",
            Self::linux => "linux",
            Self::lynxos178 => "lynxos178",
            Self::macos => "macos",
            Self::managarm => "managarm",
            Self::motor => "motor",
            Self::netbsd => "netbsd",
            Self::none => "none",
            Self::nto => "nto",
            Self::nuttx => "nuttx",
            Self::openbsd => "openbsd",
            Self::psp => "psp",
            Self::psx => "psx",
            Self::redox => "redox",
            Self::rtems => "rtems",
            Self::solaris => "solaris",
            Self::solid_asp3 => "solid_asp3",
            Self::teeos => "teeos",
            Self::trusty => "trusty",
            Self::tvos => "tvos",
            Self::uefi => "uefi",
            Self::unknown => "unknown",
            Self::vexos => "vexos",
            Self::visionos => "visionos",
            Self::vita => "vita",
            Self::vxworks => "vxworks",
            Self::wasi => "wasi",
            Self::watchos => "watchos",
            Self::windows => "windows",
            Self::xous => "xous",
            Self::zephyr => "zephyr",
            Self::zkvm => "zkvm",
        }
    }
}
impl Os {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub(crate) fn is_none(&self) -> bool {
        matches!(self, Self::none)
    }
}
impl Default for Os {
    fn default() -> Self {
        Self::none
    }
}
impl core::fmt::Display for Os {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum Env {
    gnu,
    libnx,
    macabi,
    mlibc,
    msvc,
    musl,
    newlib,
    none,
    nto70,
    nto71,
    nto71_iosock,
    nto80,
    ohos,
    p1,
    p2,
    relibc,
    sgx,
    sim,
    uclibc,
    v5,
}
impl Env {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::gnu => "gnu",
            Self::libnx => "libnx",
            Self::macabi => "macabi",
            Self::mlibc => "mlibc",
            Self::msvc => "msvc",
            Self::musl => "musl",
            Self::newlib => "newlib",
            Self::none => "",
            Self::nto70 => "nto70",
            Self::nto71 => "nto71",
            Self::nto71_iosock => "nto71_iosock",
            Self::nto80 => "nto80",
            Self::ohos => "ohos",
            Self::p1 => "p1",
            Self::p2 => "p2",
            Self::relibc => "relibc",
            Self::sgx => "sgx",
            Self::sim => "sim",
            Self::uclibc => "uclibc",
            Self::v5 => "v5",
        }
    }
}
impl Env {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub(crate) fn is_none(&self) -> bool {
        matches!(self, Self::none)
    }
}
impl Default for Env {
    fn default() -> Self {
        Self::none
    }
}
impl core::fmt::Display for Env {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum TargetFamily {
    unix,
    wasm,
    windows,
}
impl TargetFamily {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::unix => "unix",
            Self::wasm => "wasm",
            Self::windows => "windows",
        }
    }
}
impl core::fmt::Display for TargetFamily {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum Sanitizer {
    address,
    cfi,
    dataflow,
    hwaddress,
    kcfi,
    #[serde(rename = "kernel-address")]
    kernel_address,
    leak,
    memory,
    memtag,
    safestack,
    #[serde(rename = "shadow-call-stack")]
    shadow_call_stack,
    thread,
}
impl Sanitizer {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::address => "address",
            Self::cfi => "cfi",
            Self::dataflow => "dataflow",
            Self::hwaddress => "hwaddress",
            Self::kcfi => "kcfi",
            Self::kernel_address => "kernel-address",
            Self::leak => "leak",
            Self::memory => "memory",
            Self::memtag => "memtag",
            Self::safestack => "safestack",
            Self::shadow_call_stack => "shadow-call-stack",
            Self::thread => "thread",
        }
    }
}
impl core::fmt::Display for Sanitizer {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum BinaryFormat {
    coff,
    elf,
    #[serde(rename = "mach-o")]
    mach_o,
    wasm,
    xcoff,
}
impl BinaryFormat {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::coff => "coff",
            Self::elf => "elf",
            Self::mach_o => "mach-o",
            Self::wasm => "wasm",
            Self::xcoff => "xcoff",
        }
    }
}
impl BinaryFormat {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub(crate) fn is_elf(&self) -> bool {
        matches!(self, Self::elf)
    }
}
impl Default for BinaryFormat {
    fn default() -> Self {
        Self::elf
    }
}
impl core::fmt::Display for BinaryFormat {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[allow(clippy::exhaustive_enums)]
pub enum TargetEndian {
    big,
    little,
}
impl TargetEndian {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::big => "big",
            Self::little => "little",
        }
    }
}
impl TargetEndian {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub(crate) fn is_little(&self) -> bool {
        matches!(self, Self::little)
    }
}
impl Default for TargetEndian {
    fn default() -> Self {
        Self::little
    }
}
impl core::fmt::Display for TargetEndian {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[allow(clippy::exhaustive_enums)]
pub enum PanicStrategy {
    abort,
    unwind,
}
impl PanicStrategy {
    #[must_use]
    pub fn as_str(self) -> &'static str {
        match self {
            Self::abort => "abort",
            Self::unwind => "unwind",
        }
    }
}
impl PanicStrategy {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub(crate) fn is_unwind(&self) -> bool {
        matches!(self, Self::unwind)
    }
}
impl Default for PanicStrategy {
    fn default() -> Self {
        Self::unwind
    }
}
impl core::fmt::Display for PanicStrategy {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}
